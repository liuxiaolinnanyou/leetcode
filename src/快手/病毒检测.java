package 快手;

import java.util.Scanner;

/**
 * 小明最近在做病毒自动检测，他发现，在某些library 的代码段的二进制表示中，如果包含子串并且恰好有k个1，
 * 就有可能有潜在的病毒。library的二进制表示可能很大，并且子串可能很多，人工分析不可能，
 * 于是他想写个程序来先算算到底有多少个子串满足条件。如果子串内容相同，但是开始或者结束位置不一样，则被认为是不同的子串。
 * 注：子串一定是连续的。例如"010"有6个子串，分别是 "0, "1", "0", "01", "10", "010"
 * <p>
 * 输入描述：
 * 第一行是一个整数k，表示子串中有k个1就有可能是病毒。其中 0 <= k <= 1 000 000
 * 第二行是一个字符串，就是library的代码部分的二进制表示。字符串长度 <= 1 000 000。并且字符串中只包含"0"或"1".
 * 输出描述：
 * 输出一个整数，所有满足只包含k个1的子串的个数。
 * <p>
 * 输入：
 * 1
 * 1010
 * 输出：
 * 6
 * 说明：满足条件的子串有："1", "1", "10", "01", "10", "010".
 * <p>
 * 输入：
 * 2
 * 01010
 * 输出：
 * 4
 * 说明：满足条件的子串有： "101", "0101", "1010", "01010".
 * <p>
 * 输入：
 * 100
 * 01010
 * 输出：
 * 0
 */
public class 病毒检测 {
    /**
     * 子串匹配问题。子串要求有k个1，则创建一个k+1大小的数组，进行子串表示。
     * （第n个字符是否能满足子串，当第n个字符为0时，跟前面k个1有关，当第n个字符为1时，跟前面k-1个1有关）。
     * 长度为k+1的数组status存放了相连的k+1个1后面0的个数。如第n个字符为子串的最后一个字符，
     * 则该子串必须包含第n字符以及前面相连最近的k个为1的字符，可以在字符的前面加0，每添加一个连续的0，则多一个子串的组合。
     */
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int k = sc.nextInt();
        // 解决先获取一个数字在获取一个字符串存在的问题
        sc.nextLine();
        String str = sc.nextLine();
        char[] strChar = str.toCharArray();
        int[] status = new int[k + 2];

        status[0] = 1;
        int num = 0;
        long result = 0;
        for (char c : strChar) {
            if (c == '1') {
                num++;
            }
            if (c == '1') {
                status[(num) % (k + 1)] = 0;
            }
            if (num >= k) {
                result += status[(num - k) % (k + 1)];
            }
            status[num % (k + 1)]++;
        }
        System.out.println(result);
    }


    /**
     * 仔细观察和计算，相信大家都能够发现，对于任何一个已经计算好的字符串,往它的后面追加一个字符后
     * 对结果的有影响的字符串只是倒数第k+1个'1'之后的子串
     * 例: k = 2; str = 01010; result = 4
     * 如果往str后面追加1,str = 010101,对最终结果有影响的是0101(01'0101')子串
     * 如果往str后面追加0,str = 010100,对最终结果有影响的是010100('010100')子串
     * 影响主要有两个方面：
     * 影响一：不管追加的是0,还是1,最终结果都会增加1个匹配字串
     * 影响二:如果倒数第k位1前面有0，则每个0都会增加1个匹配子串
     * <p>
     * 那么可以根据这一特性保存最后k位'1'左边的0的数量，就能够利用前面字串已经计算好的结果，来对追加后字符串的结果进行计算
     */
//    public static void main(String[] args) {
//        Scanner input = new Scanner(System.in);
//        int k = Integer.parseInt(input.nextLine());
//        String str = input.nextLine();
//        long result = 0;  // 结果可能会非常大
//        int oneNum = 0;
//        int[] kCharNum = new int[k + 1]; // 建立k+1位的数组，记录最后k位'1'左边0的数量，以及后面可能出现的'1'左边0的数量，所以需要k+1位
//        kCharNum[0] = 1;  // 因为影响一，所以提前加1，也是为了解决k=0的情况
//        for (int i = 0; i < str.length(); i++) {
//            if (str.charAt(i) == '1') {
//                oneNum++;
//                // num已经加1了，需要将倒数k+1位'1'的数据清空，重新利用计数
//                kCharNum[oneNum % (k + 1)] = 0;
//            }
//            if (oneNum >= k) {
//                // result += 从当前最近1的位子往左数k位的那个1，它左边0的数量  + 1
//                // 因为已经提前加了1，所以只需加上倒数第k位0的数量(里面已经包含了加1)
//                result += kCharNum[(oneNum - k) % (k + 1)];
//            }
//            // 如果当前字符是'0',那么加1
//            // 如果当前字符是'1',则提前加1
//            // 所以都需要加1
//            kCharNum[oneNum % (k + 1)]++;
//        }
//        System.out.println(result);
//        input.close();
//    }
}

